@page "/Upload"
@inject FileManager FileManager
@attribute [Authorize]

<h1>Upload Files</h1>

<p>
    <label>
        <InputFile OnChange="@OnInputFileChange"/>
    </label>
</p>
@if (_largeUploadMessage != null)
{
    <p>Result: @_largeUploadMessage</p>
}

@code {
    private bool _shouldRender;
    string _imageUrl = "";
    bool _uploading = false;
    bool _uploadingLargeFile = false;
    string _largeUploadMessage = "";
    long _uploadedBytes;
    long _totalBytes;
    
    protected override bool ShouldRender() => _shouldRender;

    private async Task OnInputFileChange(InputFileChangeEventArgs args)
    {
        _uploadedBytes = 0;

        // Disable the file input field
        _uploadingLargeFile = true;
        await InvokeAsync(StateHasChanged);

        // calculate the chunks we have to send
        _totalBytes = args.File.Size;
        const long chunkSize = 400000; // fairly arbitrary
        var numChunks = _totalBytes / chunkSize;
        var remainder = _totalBytes % chunkSize;

        // get new filename with a bit of entropy
        var justFileName = Path.GetFileNameWithoutExtension(args.File.Name);
        var extension = Path.GetExtension(args.File.Name);
        var newFileNameWithoutPath = $"{justFileName}-{DateTime.Now.Ticks.ToString()}{extension}";

        var firstChunk = true;
        
        // Open the input and output file streams
        await using (var inStream = args.File.OpenReadStream(long.MaxValue))
        {
            long percent = 0;
            for (var i = 0; i < numChunks; i++)
            {
                // Read the next chunk
                var buffer = new byte[chunkSize];
                var readAsync = await inStream.ReadAsync(buffer, 0, buffer.Length);

                // create the FileChunk object
                var chunk = new FileChunk
                {
                    Data = buffer,
                    FileNameNoPath = newFileNameWithoutPath,
                    Offset = _uploadedBytes,
                    FirstChunk = firstChunk
                };

                // upload this chunk
                await FileManager.UploadFileChunk(chunk);

                firstChunk = false; // no longer the first chunk

                // Update our progress data and UI
                _uploadedBytes += chunkSize;
                percent = _uploadedBytes * 100 / _totalBytes;
                // Report progress with a string
                _largeUploadMessage = $"Uploading {args.File.Name} {percent}%";
                await InvokeAsync(StateHasChanged);
            }

            if (remainder > 0)
            {
                // Same stuff as above, just with the leftover chunk data
                var buffer = new byte[remainder];
                var readAsync = await inStream.ReadAsync(buffer, 0, buffer.Length);

                // create the FileChunk object
                var chunk = new FileChunk
                {
                    Data = buffer,
                    FileNameNoPath = newFileNameWithoutPath,
                    Offset = _uploadedBytes,
                    FirstChunk = firstChunk
                };

                // upload this chunk
                await FileManager.UploadFileChunk(chunk);

                _uploadedBytes += remainder;
                percent = _uploadedBytes * 100 / _totalBytes;
                _largeUploadMessage = $"Uploading {args.File.Name} {percent}%";
                await InvokeAsync(StateHasChanged);
            }
        }

        _largeUploadMessage = "Upload Complete.";
        _uploadingLargeFile = false;
    }
}
